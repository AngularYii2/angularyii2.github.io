{"version":3,"sources":["modules/tooltip.js"],"names":["angular","target","provider","placement","this","defaults","template","contentTemplate","trigger","keyboard","html","show","title","type","delay","autoClose","bsEnabled","viewport","selector","padding","$get","String","htmlReplaceRegExp","$body","nodeName","element","toLowerCase","split","enterAnimateCallback","scope","$emit","options","prefixEvent","$tooltip","leaveAnimateCallback","_tipToHide","leave","$isShown","blur","tipElement","forEach","triggers","on","toggle","unbindTriggerEvents","enter","i","length","off","bindKeyboardEvents","$onKeyUp","isTouch","$onFocusElementMouseDown","unbindKeyboardEvents","_autoCloseEventsBinded","bindAutoCloseEvents","$timeout","hide","unbindAutoCloseEvents","stopEventPropagation","event","getPosition","$element","rect","stopPropagation","width","extend","elRect","height","p","top","left","dimensions","offset","el","scroll","isBody","document","documentElement","$window","getCalculatedOffset","position","actualWidth","actualHeight","outerDims","clientWidth","innerHeight","tip","marginTop","parseInt","using","props","css","isNaN","right","marginLeft","setOffset","delta","getViewportAdjustedDelta","isVertical","replaceArrow","arrowDelta","test","arrowOffsetPosition","viewportPadding","topEdgeOffset","$viewport","viewportDimensions","leftEdgeOffset","rightEdgeOffset","dimension","isHorizontal","findElement","$arrow","clearTimeout","timeout","tipScope","$destroy","$$phase","$options","config","fetchTemplate","$scope","$new","$rootScope","$id","attr","map","parseFloat","$sce","trustAsHtml","$setEnabled","$$postDigest","id","$hide","setEnabled","isEnabled","$promise","templateEl","contentEl","then","tipLinker","tipTemplate","isObject","init","data","isNumber","container","tipContainer","bindTriggerEvents","isElement","destroyTipElement","hoverState","parent","after","lastChild","display","visibility","clonedElement","safeDigest","version","minor","addClass","animation","$animate","customClass","$$rAF","$applyPlacement","focus","_blur","replace","elementPosition","autoPlace","originalPlacement","containerPosition","indexOf","tipHeight","removeClass","tipPosition","applyPlacement","tipWidth","evt","preventDefault","fetchPromises","cache","$templateCache","res","TooltipFactory","$http","get","directive","restrict","trim","isString","$location","link","falseValueRegExp","transclusion","dataTarget","key","isDefined","hasOwnProperty","oldValue","tooltip","$observe","newValue","bsTooltip","$watch","bsShow","match","setViewport","$on","destroy"],"mappings":"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","file":"modules/tooltip.min.js","sourcesContent":["'use strict';\n\nangular.module('mgcrea.ngStrap.tooltip', ['mgcrea.ngStrap.helpers.dimensions'])\n\n  .provider('$tooltip', function() {\n\n    var defaults = this.defaults = {\n      animation: 'am-fade',\n      customClass: '',\n      prefixClass: 'tooltip',\n      prefixEvent: 'tooltip',\n      container: false,\n      target: false,\n      placement: 'top',\n      template: 'tooltip/tooltip.tpl.html',\n      contentTemplate: false,\n      trigger: 'hover focus',\n      keyboard: false,\n      html: false,\n      show: false,\n      title: '',\n      type: '',\n      delay: 0,\n      autoClose: false,\n      bsEnabled: true,\n      viewport: {\n       selector: 'body',\n       padding: 0\n      }\n    };\n\n    this.$get = function($window, $rootScope, $compile, $q, $templateCache, $http, $animate, $sce, dimensions, $$rAF, $timeout) {\n\n      var trim = String.prototype.trim;\n      var isTouch = 'createTouch' in $window.document;\n      var htmlReplaceRegExp = /ng-bind=\"/ig;\n      var $body = angular.element($window.document);\n\n      function TooltipFactory(element, config) {\n\n        var $tooltip = {};\n\n        // Common vars\n        var nodeName = element[0].nodeName.toLowerCase();\n        var options = $tooltip.$options = angular.extend({}, defaults, config);\n        $tooltip.$promise = fetchTemplate(options.template);\n        var scope = $tooltip.$scope = options.scope && options.scope.$new() || $rootScope.$new();\n        if(options.delay && angular.isString(options.delay)) {\n          var split = options.delay.split(',').map(parseFloat);\n          options.delay = split.length > 1 ? {show: split[0], hide: split[1]} : split[0];\n        }\n\n        // store $id to identify the triggering element in events\n        // give priority to options.id, otherwise, try to use\n        // element id if defined\n        $tooltip.$id = options.id || element.attr('id') || '';\n\n        // Support scope as string options\n        if(options.title) {\n          scope.title = $sce.trustAsHtml(options.title);\n        }\n\n        // Provide scope helpers\n        scope.$setEnabled = function(isEnabled) {\n          scope.$$postDigest(function() {\n            $tooltip.setEnabled(isEnabled);\n          });\n        };\n        scope.$hide = function() {\n          scope.$$postDigest(function() {\n            $tooltip.hide();\n          });\n        };\n        scope.$show = function() {\n          scope.$$postDigest(function() {\n            $tooltip.show();\n          });\n        };\n        scope.$toggle = function() {\n          scope.$$postDigest(function() {\n            $tooltip.toggle();\n          });\n        };\n        // Publish isShown as a protected var on scope\n        $tooltip.$isShown = scope.$isShown = false;\n\n        // Private vars\n        var timeout, hoverState;\n\n        // Support contentTemplate option\n        if(options.contentTemplate) {\n          $tooltip.$promise = $tooltip.$promise.then(function(template) {\n            var templateEl = angular.element(template);\n            return fetchTemplate(options.contentTemplate)\n            .then(function(contentTemplate) {\n              var contentEl = findElement('[ng-bind=\"content\"]', templateEl[0]);\n              if(!contentEl.length) contentEl = findElement('[ng-bind=\"title\"]', templateEl[0]);\n              contentEl.removeAttr('ng-bind').html(contentTemplate);\n              return templateEl[0].outerHTML;\n            });\n          });\n        }\n\n        // Fetch, compile then initialize tooltip\n        var tipLinker, tipElement, tipTemplate, tipContainer, tipScope;\n        $tooltip.$promise.then(function(template) {\n          if(angular.isObject(template)) template = template.data;\n          if(options.html) template = template.replace(htmlReplaceRegExp, 'ng-bind-html=\"');\n          template = trim.apply(template);\n          tipTemplate = template;\n          tipLinker = $compile(template);\n          $tooltip.init();\n        });\n\n        $tooltip.init = function() {\n\n          // Options: delay\n          if (options.delay && angular.isNumber(options.delay)) {\n            options.delay = {\n              show: options.delay,\n              hide: options.delay\n            };\n          }\n\n          // Replace trigger on touch devices ?\n          // if(isTouch && options.trigger === defaults.trigger) {\n          //   options.trigger.replace(/hover/g, 'click');\n          // }\n\n          // Options : container\n          if(options.container === 'self') {\n            tipContainer = element;\n          } else if(angular.isElement(options.container)) {\n            tipContainer = options.container;\n          } else if(options.container) {\n            tipContainer = findElement(options.container);\n          }\n\n          // Options: trigger\n          bindTriggerEvents();\n\n          // Options: target\n          if(options.target) {\n            options.target = angular.isElement(options.target) ? options.target : findElement(options.target);\n          }\n\n          // Options: show\n          if(options.show) {\n            scope.$$postDigest(function() {\n              options.trigger === 'focus' ? element[0].focus() : $tooltip.show();\n            });\n          }\n\n        };\n\n        $tooltip.destroy = function() {\n\n          // Unbind events\n          unbindTriggerEvents();\n\n          // Remove element\n          destroyTipElement();\n\n          // Destroy scope\n          scope.$destroy();\n\n        };\n\n        $tooltip.enter = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'in';\n          if (!options.delay || !options.delay.show) {\n            return $tooltip.show();\n          }\n\n          timeout = setTimeout(function() {\n            if (hoverState ==='in') $tooltip.show();\n          }, options.delay.show);\n\n        };\n\n        $tooltip.show = function() {\n          if (!options.bsEnabled || $tooltip.$isShown) return;\n\n          scope.$emit(options.prefixEvent + '.show.before', $tooltip);\n          var parent, after;\n          if (options.container) {\n            parent = tipContainer;\n            if (tipContainer[0].lastChild) {\n              after = angular.element(tipContainer[0].lastChild);\n            } else {\n              after = null;\n            }\n          } else {\n            parent = null;\n            after = element;\n          }\n\n\n          // Hide any existing tipElement\n          if(tipElement) destroyTipElement();\n          // Fetch a cloned element linked from template\n          tipScope = $tooltip.$scope.$new();\n          tipElement = $tooltip.$element = tipLinker(tipScope, function(clonedElement, scope) {});\n\n          // Set the initial positioning.  Make the tooltip invisible\n          // so IE doesn't try to focus on it off screen.\n          tipElement.css({top: '-9999px', left: '-9999px', right: 'auto', display: 'block', visibility: 'hidden'});\n\n          // Options: animation\n          if(options.animation) tipElement.addClass(options.animation);\n          // Options: type\n          if(options.type) tipElement.addClass(options.prefixClass + '-' + options.type);\n          // Options: custom classes\n          if(options.customClass) tipElement.addClass(options.customClass);\n\n          // Append the element, without any animations.  If we append\n          // using $animate.enter, some of the animations cause the placement\n          // to be off due to the transforms.\n          after ? after.after(tipElement) : parent.prepend(tipElement);\n\n          $tooltip.$isShown = scope.$isShown = true;\n          safeDigest(scope);\n\n          // Now, apply placement\n          $tooltip.$applyPlacement();\n\n          // Once placed, animate it.\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.enter(tipElement, parent, after, enterAnimateCallback);\n          } else {\n            $animate.enter(tipElement, parent, after).then(enterAnimateCallback);\n          }\n          safeDigest(scope);\n\n          $$rAF(function () {\n            // Once the tooltip is placed and the animation starts, make the tooltip visible\n            if(tipElement) tipElement.css({visibility: 'visible'});\n          });\n\n          // Bind events\n          if(options.keyboard) {\n            if(options.trigger !== 'focus') {\n              $tooltip.focus();\n            }\n            bindKeyboardEvents();\n          }\n\n          if(options.autoClose) {\n            bindAutoCloseEvents();\n          }\n\n        };\n\n        function enterAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.show', $tooltip);\n        }\n\n        $tooltip.leave = function() {\n\n          clearTimeout(timeout);\n          hoverState = 'out';\n          if (!options.delay || !options.delay.hide) {\n            return $tooltip.hide();\n          }\n          timeout = setTimeout(function () {\n            if (hoverState === 'out') {\n              $tooltip.hide();\n            }\n          }, options.delay.hide);\n\n        };\n\n        var _blur;\n        var _tipToHide;\n        $tooltip.hide = function(blur) {\n\n          if(!$tooltip.$isShown) return;\n          scope.$emit(options.prefixEvent + '.hide.before', $tooltip);\n\n          // store blur value for leaveAnimateCallback to use\n          _blur = blur;\n\n          // store current tipElement reference to use\n          // in leaveAnimateCallback\n          _tipToHide = tipElement;\n\n          // Support v1.2+ $animate\n          // https://github.com/angular/angular.js/issues/11713\n          if(angular.version.minor <= 2) {\n            $animate.leave(tipElement, leaveAnimateCallback);\n          } else {\n            $animate.leave(tipElement).then(leaveAnimateCallback);\n          }\n\n          $tooltip.$isShown = scope.$isShown = false;\n          safeDigest(scope);\n\n          // Unbind events\n          if(options.keyboard && tipElement !== null) {\n            unbindKeyboardEvents();\n          }\n\n          if(options.autoClose && tipElement !== null) {\n            unbindAutoCloseEvents();\n          }\n        };\n\n        function leaveAnimateCallback() {\n          scope.$emit(options.prefixEvent + '.hide', $tooltip);\n\n          // check if current tipElement still references\n          // the same element when hide was called\n          if (tipElement === _tipToHide) {\n            // Allow to blur the input when hidden, like when pressing enter key\n            if(_blur && options.trigger === 'focus') {\n              return element[0].blur();\n            }\n\n            // clean up child scopes\n            destroyTipElement();\n          }\n        }\n\n        $tooltip.toggle = function() {\n          $tooltip.$isShown ? $tooltip.leave() : $tooltip.enter();\n        };\n\n        $tooltip.focus = function() {\n          tipElement[0].focus();\n        };\n\n        $tooltip.setEnabled = function(isEnabled) {\n          options.bsEnabled = isEnabled;\n        };\n\n        $tooltip.setViewport = function(viewport) {\n          options.viewport = viewport;\n        };\n\n        // Protected methods\n\n        $tooltip.$applyPlacement = function() {\n          if(!tipElement) return;\n\n          // Determine if we're doing an auto or normal placement\n          var placement = options.placement,\n              autoToken = /\\s?auto?\\s?/i,\n              autoPlace  = autoToken.test(placement);\n\n          if (autoPlace) {\n            placement = placement.replace(autoToken, '') || defaults.placement;\n          }\n\n          // Need to add the position class before we get\n          // the offsets\n          tipElement.addClass(options.placement);\n\n          // Get the position of the target element\n          // and the height and width of the tooltip so we can center it.\n          var elementPosition = getPosition(),\n              tipWidth = tipElement.prop('offsetWidth'),\n              tipHeight = tipElement.prop('offsetHeight');\n\n          // If we're auto placing, we need to check the positioning\n          if (autoPlace) {\n            var originalPlacement = placement;\n            var container = options.container ? findElement(options.container) : element.parent();\n            var containerPosition = getPosition(container);\n\n            // Determine if the vertical placement\n            if (originalPlacement.indexOf('bottom') >= 0 && elementPosition.bottom + tipHeight > containerPosition.bottom) {\n              placement = originalPlacement.replace('bottom', 'top');\n            } else if (originalPlacement.indexOf('top') >= 0 && elementPosition.top - tipHeight < containerPosition.top) {\n              placement = originalPlacement.replace('top', 'bottom');\n            }\n\n            // Determine the horizontal placement\n            // The exotic placements of left and right are opposite of the standard placements.  Their arrows are put on the left/right\n            // and flow in the opposite direction of their placement.\n            if ((originalPlacement === 'right' || originalPlacement === 'bottom-left' || originalPlacement === 'top-left') &&\n                elementPosition.right + tipWidth > containerPosition.width) {\n\n              placement = originalPlacement === 'right' ? 'left' : placement.replace('left', 'right');\n            } else if ((originalPlacement === 'left' || originalPlacement === 'bottom-right' || originalPlacement === 'top-right') &&\n                elementPosition.left - tipWidth < containerPosition.left) {\n\n              placement = originalPlacement === 'left' ? 'right' : placement.replace('right', 'left');\n            }\n\n            tipElement.removeClass(originalPlacement).addClass(placement);\n          }\n\n          // Get the tooltip's top and left coordinates to center it with this directive.\n          var tipPosition = getCalculatedOffset(placement, elementPosition, tipWidth, tipHeight);\n          applyPlacement(tipPosition, placement);\n        };\n\n        $tooltip.$onKeyUp = function(evt) {\n          if (evt.which === 27 && $tooltip.$isShown) {\n            $tooltip.hide();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusKeyUp = function(evt) {\n          if (evt.which === 27) {\n            element[0].blur();\n            evt.stopPropagation();\n          }\n        };\n\n        $tooltip.$onFocusElementMouseDown = function(evt) {\n          evt.preventDefault();\n          evt.stopPropagation();\n          // Some browsers do not auto-focus buttons (eg. Safari)\n          $tooltip.$isShown ? element[0].blur() : element[0].focus();\n        };\n\n        // bind/unbind events\n        function bindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          angular.forEach(triggers, function(trigger) {\n            if(trigger === 'click') {\n              element.on('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.on(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.on(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.on(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          });\n        }\n\n        function unbindTriggerEvents() {\n          var triggers = options.trigger.split(' ');\n          for (var i = triggers.length; i--;) {\n            var trigger = triggers[i];\n            if(trigger === 'click') {\n              element.off('click', $tooltip.toggle);\n            } else if(trigger !== 'manual') {\n              element.off(trigger === 'hover' ? 'mouseenter' : 'focus', $tooltip.enter);\n              element.off(trigger === 'hover' ? 'mouseleave' : 'blur', $tooltip.leave);\n              nodeName === 'button' && trigger !== 'hover' && element.off(isTouch ? 'touchstart' : 'mousedown', $tooltip.$onFocusElementMouseDown);\n            }\n          }\n        }\n\n        function bindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.on('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.on('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        function unbindKeyboardEvents() {\n          if(options.trigger !== 'focus') {\n            tipElement.off('keyup', $tooltip.$onKeyUp);\n          } else {\n            element.off('keyup', $tooltip.$onFocusKeyUp);\n          }\n        }\n\n        var _autoCloseEventsBinded = false;\n        function bindAutoCloseEvents() {\n          // use timeout to hookup the events to prevent\n          // event bubbling from being processed imediately.\n          $timeout(function() {\n            // Stop propagation when clicking inside tooltip\n            tipElement.on('click', stopEventPropagation);\n\n            // Hide when clicking outside tooltip\n            $body.on('click', $tooltip.hide);\n\n            _autoCloseEventsBinded = true;\n          }, 0, false);\n        }\n\n        function unbindAutoCloseEvents() {\n          if (_autoCloseEventsBinded) {\n            tipElement.off('click', stopEventPropagation);\n            $body.off('click', $tooltip.hide);\n            _autoCloseEventsBinded = false;\n          }\n        }\n\n        function stopEventPropagation(event) {\n          event.stopPropagation();\n        }\n\n        // Private methods\n\n        function getPosition($element) {\n          $element = $element || (options.target || element);\n\n          var el = $element[0],\n              isBody = el.tagName === 'BODY';\n\n          var elRect = el.getBoundingClientRect();\n          var rect = {};\n\n          // IE8 has issues with angular.extend and using elRect directly.\n          // By coping the values of elRect into a new object, we can continue to use extend\n          for (var p in elRect) {\n            // DO NOT use hasOwnProperty when inspecting the return of getBoundingClientRect.\n            rect[p] = elRect[p];\n          }\n\n          if (rect.width === null) {\n            // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n            rect = angular.extend({}, rect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });\n          }\n          var elOffset = isBody ? { top: 0, left: 0 } : dimensions.offset(el),\n              scroll = { scroll:  isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.prop('scrollTop') || 0 },\n              outerDims = isBody ? { width: document.documentElement.clientWidth, height: $window.innerHeight } : null;\n\n          return angular.extend({}, rect, scroll, outerDims, elOffset);\n        }\n\n        function getCalculatedOffset(placement, position, actualWidth, actualHeight) {\n          var offset;\n          var split = placement.split('-');\n\n          switch (split[0]) {\n          case 'right':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left + position.width\n            };\n            break;\n          case 'bottom':\n            offset = {\n              top: position.top + position.height,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          case 'left':\n            offset = {\n              top: position.top + position.height / 2 - actualHeight / 2,\n              left: position.left - actualWidth\n            };\n            break;\n          default:\n            offset = {\n              top: position.top - actualHeight,\n              left: position.left + position.width / 2 - actualWidth / 2\n            };\n            break;\n          }\n\n          if(!split[1]) {\n            return offset;\n          }\n\n          // Add support for corners @todo css\n          if(split[0] === 'top' || split[0] === 'bottom') {\n            switch (split[1]) {\n            case 'left':\n              offset.left = position.left;\n              break;\n            case 'right':\n              offset.left =  position.left + position.width - actualWidth;\n            }\n          } else if(split[0] === 'left' || split[0] === 'right') {\n            switch (split[1]) {\n            case 'top':\n              offset.top = position.top - actualHeight;\n              break;\n            case 'bottom':\n              offset.top = position.top + position.height;\n            }\n          }\n\n          return offset;\n        }\n\n        function applyPlacement(offset, placement) {\n          var tip = tipElement[0],\n              width = tip.offsetWidth,\n              height = tip.offsetHeight;\n\n          // manually read margins because getBoundingClientRect includes difference\n          var marginTop = parseInt(dimensions.css(tip, 'margin-top'), 10),\n              marginLeft = parseInt(dimensions.css(tip, 'margin-left'), 10);\n\n          // we must check for NaN for ie 8/9\n          if (isNaN(marginTop)) marginTop  = 0;\n          if (isNaN(marginLeft)) marginLeft = 0;\n\n          offset.top  = offset.top + marginTop;\n          offset.left = offset.left + marginLeft;\n\n          // dimensions setOffset doesn't round pixel values\n          // so we use setOffset directly with our own function\n          dimensions.setOffset(tip, angular.extend({\n            using: function (props) {\n              tipElement.css({\n                top: Math.round(props.top) + 'px',\n                left: Math.round(props.left) + 'px',\n                right: ''\n              });\n            }\n          }, offset), 0);\n\n          // check to see if placing tip in new offset caused the tip to resize itself\n          var actualWidth = tip.offsetWidth,\n              actualHeight = tip.offsetHeight;\n\n          if (placement === 'top' && actualHeight !== height) {\n            offset.top = offset.top + height - actualHeight;\n          }\n\n          // If it's an exotic placement, exit now instead of\n          // applying a delta and changing the arrow\n          if (/top-left|top-right|bottom-left|bottom-right/.test(placement)) return;\n\n          var delta = getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);\n\n          if (delta.left) {\n            offset.left += delta.left;\n          } else {\n            offset.top += delta.top;\n          }\n\n          dimensions.setOffset(tip, offset);\n\n          if (/top|right|bottom|left/.test(placement)) {\n            var isVertical = /top|bottom/.test(placement),\n                arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight,\n                arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';\n\n            replaceArrow(arrowDelta, tip[arrowOffsetPosition], isVertical);\n          }\n        }\n\n        function getViewportAdjustedDelta(placement, position, actualWidth, actualHeight) {\n          var delta = { top: 0, left: 0 },\n              $viewport = options.viewport && findElement(options.viewport.selector || options.viewport);\n\n          if (!$viewport) {\n           return delta;\n          }\n\n          var viewportPadding = options.viewport && options.viewport.padding || 0,\n              viewportDimensions = getPosition($viewport);\n\n          if (/right|left/.test(placement)) {\n            var topEdgeOffset    = position.top - viewportPadding - viewportDimensions.scroll,\n                bottomEdgeOffset = position.top + viewportPadding - viewportDimensions.scroll + actualHeight;\n            if (topEdgeOffset < viewportDimensions.top) { // top overflow\n              delta.top = viewportDimensions.top - topEdgeOffset;\n            } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n              delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;\n            }\n          } else {\n            var leftEdgeOffset  = position.left - viewportPadding,\n                rightEdgeOffset = position.left + viewportPadding + actualWidth;\n            if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n              delta.left = viewportDimensions.left - leftEdgeOffset;\n            } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow\n              delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;\n            }\n          }\n\n          return delta;\n        }\n\n        function replaceArrow(delta, dimension, isHorizontal) {\n          var $arrow = findElement('.tooltip-arrow, .arrow', tipElement[0]);\n\n          $arrow.css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n                .css(isHorizontal ? 'top' : 'left', '');\n        }\n\n        function destroyTipElement() {\n          // Cancel pending callbacks\n          clearTimeout(timeout);\n\n          if($tooltip.$isShown && tipElement !== null) {\n            if(options.autoClose) {\n              unbindAutoCloseEvents();\n            }\n\n            if(options.keyboard) {\n              unbindKeyboardEvents();\n            }\n          }\n\n          if(tipScope) {\n            tipScope.$destroy();\n            tipScope = null;\n          }\n\n          if(tipElement) {\n            tipElement.remove();\n            tipElement = $tooltip.$element = null;\n          }\n        }\n\n        return $tooltip;\n\n      }\n\n      // Helper functions\n\n      function safeDigest(scope) {\n        scope.$$phase || (scope.$root && scope.$root.$$phase) || scope.$digest();\n      }\n\n      function findElement(query, element) {\n        return angular.element((element || document).querySelectorAll(query));\n      }\n\n      var fetchPromises = {};\n      function fetchTemplate(template) {\n        if(fetchPromises[template]) return fetchPromises[template];\n        return (fetchPromises[template] = $http.get(template, {cache: $templateCache}).then(function(res) {\n          return res.data;\n        }));\n      }\n\n      return TooltipFactory;\n\n    };\n\n  })\n\n  .directive('bsTooltip', function($window, $location, $sce, $tooltip, $$rAF) {\n\n    return {\n      restrict: 'EAC',\n      scope: true,\n      link: function postLink(scope, element, attr, transclusion) {\n\n        // Directive options\n        var options = {scope: scope};\n        angular.forEach(['template', 'contentTemplate', 'placement', 'container', 'delay', 'trigger', 'html', 'animation', 'backdropAnimation', 'type', 'customClass', 'id'], function(key) {\n          if(angular.isDefined(attr[key])) options[key] = attr[key];\n        });\n\n        // use string regex match boolean attr falsy values, leave truthy values be\n        var falseValueRegExp = /^(false|0|)$/i;\n        angular.forEach(['html', 'container'], function(key) {\n          if(angular.isDefined(attr[key]) && falseValueRegExp.test(attr[key]))\n            options[key] = false;\n        });\n\n        // should not parse target attribute (anchor tag), only data-target #1454\n        var dataTarget = element.attr('data-target');\n        if(angular.isDefined(dataTarget)) {\n          if(falseValueRegExp.test(dataTarget))\n            options.target = false;\n          else\n            options.target = dataTarget;\n        }\n\n        // overwrite inherited title value when no value specified\n        // fix for angular 1.3.1 531a8de72c439d8ddd064874bf364c00cedabb11\n        if (!scope.hasOwnProperty('title')){\n          scope.title = '';\n        }\n\n        // Observe scope attributes for change\n        attr.$observe('title', function(newValue) {\n          if (angular.isDefined(newValue) || !scope.hasOwnProperty('title')) {\n            var oldValue = scope.title;\n            scope.title = $sce.trustAsHtml(newValue);\n            angular.isDefined(oldValue) && $$rAF(function() {\n              tooltip && tooltip.$applyPlacement();\n            });\n          }\n        });\n\n        // Support scope as an object\n        attr.bsTooltip && scope.$watch(attr.bsTooltip, function(newValue, oldValue) {\n          if(angular.isObject(newValue)) {\n            angular.extend(scope, newValue);\n          } else {\n            scope.title = newValue;\n          }\n          angular.isDefined(oldValue) && $$rAF(function() {\n            tooltip && tooltip.$applyPlacement();\n          });\n        }, true);\n\n        // Visibility binding support\n        attr.bsShow && scope.$watch(attr.bsShow, function(newValue, oldValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|,?(tooltip),?/i);\n          newValue === true ? tooltip.show() : tooltip.hide();\n        });\n\n        // Enabled binding support\n        attr.bsEnabled && scope.$watch(attr.bsEnabled, function(newValue, oldValue) {\n          // console.warn('scope.$watch(%s)', attr.bsEnabled, newValue, oldValue);\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          if(angular.isString(newValue)) newValue = !!newValue.match(/true|1|,?(tooltip),?/i);\n          newValue === false ? tooltip.setEnabled(false) : tooltip.setEnabled(true);\n        });\n\n        // Viewport support\n        attr.viewport && scope.$watch(attr.viewport, function (newValue) {\n          if(!tooltip || !angular.isDefined(newValue)) return;\n          tooltip.setViewport(newValue);\n        });\n\n        // Initialize popover\n        var tooltip = $tooltip(element, options);\n\n        // Garbage collection\n        scope.$on('$destroy', function() {\n          if(tooltip) tooltip.destroy();\n          options = null;\n          tooltip = null;\n        });\n\n      }\n    };\n\n  });\n"],"sourceRoot":"/source/"}